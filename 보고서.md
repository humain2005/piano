팀원 역할 분담
-최태인: 의견 제시, 검토, 코드 작성, 영상 촬영, 보고서 작성
-권도윤: 의견 제시, 검토, 코드 작성

주요 클래스 및 함수/기능 설명
1.Note 클래스
-역할: 하나의 음 정보를 저장하는 데이터 클래스
-기능: 연산자 오버로딩으로 비교와 출력 지원
2.SoundElement 클래스
-역할: 소리나는 음과 무음의 공통 인터페이스
-기능: 다형성을 지원하여 다양한 음 요소를 같은 방식으로 다룰 수 있도록 지원
3.ToneNote 클래스
-역할: 실제 사운드가 나는 음표를 표현하는 클래스
-기능: 해당 음의 사인파 형태 샘플 생성
4.RestNote 클래스
-역할: 무음을 표현하는 클래스
-기능: 무음은 0으로 채워진 클래스 생성
5.writeWavFile 함수
-역할: 생성된 오디어 샘플 파일을 .wav 파일로 저장
-기능: wav 포멧에 맞는 헤더를 작성하고, 샘플 데이터를 바이너리 형태로 파일에 저장
6.main 함수
-역할: 전체 흐름 제어 및 사용자 인터페이스 역할
-기능: 문자열 입력, 각 문자에 대응 되는 음표 및 쉼표를 벡터에 저장, 모든 음 요소의 오디어 샘플 채취 및 sample 벡터 저장, .wav 파일 저장, PlaySoundA 함수로 오디오 재생

템플릿/오버로딩/다형성 적용 포인트
1.템플릿 적용 포인트
template<typename T>
void printVector(const std::vector<T>& v) {
    for (const auto& item : v) {
        std::cout << item << " ";
    }
    std::cout << "\n";
}
-다양한 타입의 벡터 출력 지원
2.연산자 오버로딩 적용 포인트
bool operator==(const Note& other) const {
    return name == other.name && frequency == other.frequency;
}
friend std::ostream& operator<<(std::ostream& os, const Note& n) {
    return os << n.name << "(" << n.frequency << "Hz)";
}
-비교/출력 가능 사용자 정의
3.다형성 오버로딩 적용 포인트
class SoundElement {
public:
    virtual void appendToBuffer(std::vector<short>& buffer) const = 0;
    virtual ~SoundElement() = default;
};
-다양한 음 요소를 같은 방식으로 처리

느낀점 및 개선점
20240960 최태인: 이번 프로젝트는 C++의 객체지향 프로그래밍 요소들을 종합적으로 활용해볼 수 있는 경험이었다. 클래스와 상속, 다형성은 물론, 함수 오버로딩과 연산자 오버로딩, 템플릿 함수, 콘솔 입출력까지 다양한 문법 요소가 하나의 프로그램 안에 녹아 있어 실습 효과가 높았다. 특히 추상 클래스인 SoundElement를 기반으로 ToneNote와 RestNote가 기능을 분리해 구현된 구조를 통해 다형성의 장점을 체감할 수 있었다. 또한 Note 클래스에서는 출력 연산자와 동등 비교 연산자의 오버로딩을 통해 객체지향적 설계의 효율성과 가독성을 확인할 수 있었다. 실제로 음표를 받아 사인파로 변환하고 이를 .wav 형식으로 저장 및 재생하는 전체 흐름을 구현하면서, C++이 단순한 텍스트 처리나 알고리즘 구현을 넘어 현실 세계와 상호작용할 수 있는 언어임을 체감할 수 있었다. 그외에도 조원과 함께 기획 및 설계 단계에서 간단한 아이디어를 함께 나누고 기능 구현 방향을 정했던 과정은 협업할 수 있었다. 다만 시간 부족으로 인해 일부 기능을 추가하지 못한 점을 아쉽게 여겼다. 차후 지금의 프로그램에서 음의 길이 및 공백의 길이 등을 따로 조율하는 기능을 추가하면 좋을 듯 하다. 전체적으로 이번 프로젝트는 C++에 대한 이해도를 한층 높일 수 있었던 뜻깊은 시간이었다.













