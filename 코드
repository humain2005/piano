#include <iostream>
#include <fstream>
#include <cmath>
#include <map>
#include <string>
#include <vector>
#include <memory>
#include <windows.h>
#include <mmsystem.h>
#pragma comment(lib, "winmm.lib")

const int SAMPLE_RATE = 44100;
const int BITS_PER_SAMPLE = 16;
const int CHANNELS = 1;
const int DEFAULT_DURATION = 300; // ms

//-----------------------------------------------
// Note 클래스 (연산자 오버로딩 포함)
//-----------------------------------------------
class Note {
public:
    std::string name;
    double frequency;

    Note() : name(""), frequency(0) {}
    Note(const std::string& n, double f) : name(n), frequency(f) {}

    bool operator==(const Note& other) const {
        return name == other.name && frequency == other.frequency;
    }

    friend std::ostream& operator<<(std::ostream& os, const Note& n) {
        return os << n.name << "(" << n.frequency << "Hz)";
    }
};

//-----------------------------------------------
// 추상 클래스 SoundElement (다형성 구현용)
//-----------------------------------------------
class SoundElement {
public:
    virtual void appendToBuffer(std::vector<short>& buffer) const = 0;
    virtual ~SoundElement() = default;
};

//-----------------------------------------------
// 음표 클래스 (ToneNote)
//-----------------------------------------------
class ToneNote : public SoundElement {
    Note note;
    int duration;
public:
    ToneNote(const Note& n, int d = DEFAULT_DURATION) : note(n), duration(d) {}

    void appendToBuffer(std::vector<short>& buffer) const override {
        int samples = SAMPLE_RATE * duration / 1000;
        for (int i = 0; i < samples; ++i) {
            double t = static_cast<double>(i) / SAMPLE_RATE;
            short sample = static_cast<short>(32760 * sin(2 * 3.141592653589793 * note.frequency * t));
            buffer.push_back(sample);
        }
    }
};

//-----------------------------------------------
// 휴지음 클래스 (RestNote)
//-----------------------------------------------
class RestNote : public SoundElement {
    int duration;
public:
    RestNote(int d = DEFAULT_DURATION) : duration(d) {}

    void appendToBuffer(std::vector<short>& buffer) const override {
        int samples = SAMPLE_RATE * duration / 1000;
        for (int i = 0; i < samples; ++i) {
            buffer.push_back(0);
        }
    }
};

//-----------------------------------------------
// WAV 파일 저장 함수
//-----------------------------------------------
void writeWavFile(const std::string& filename, const std::vector<short>& samples) {
    std::ofstream file(filename, std::ios::binary);
    int dataSize = samples.size() * sizeof(short);
    int fileSize = 36 + dataSize;

    file.write("RIFF", 4);
    file.write(reinterpret_cast<const char*>(&fileSize), 4);
    file.write("WAVEfmt ", 8);

    int fmtSize = 16;
    short audioFormat = 1;
    short blockAlign = CHANNELS * BITS_PER_SAMPLE / 8;
    int byteRate = SAMPLE_RATE * blockAlign;

    file.write(reinterpret_cast<const char*>(&fmtSize), 4);
    file.write(reinterpret_cast<const char*>(&audioFormat), 2);
    file.write(reinterpret_cast<const char*>(&CHANNELS), 2);
    file.write(reinterpret_cast<const char*>(&SAMPLE_RATE), 4);
    file.write(reinterpret_cast<const char*>(&byteRate), 4);
    file.write(reinterpret_cast<const char*>(&blockAlign), 2);
    file.write(reinterpret_cast<const char*>(&BITS_PER_SAMPLE), 2);

    file.write("data", 4);
    file.write(reinterpret_cast<const char*>(&dataSize), 4);
    file.write(reinterpret_cast<const char*>(samples.data()), dataSize);
    file.close();
}

//-----------------------------------------------
// 템플릿 함수 (벡터 출력)
//-----------------------------------------------
template<typename T>
void printVector(const std::vector<T>& v) {
    for (const auto& item : v) {
        std::cout << item << " ";
    }
    std::cout << "\n";
}

//-----------------------------------------------
// Main 함수 (전체 통합)
//-----------------------------------------------
int main() {
    std::map<char, Note> notes = {
        {'a', {"C", 261.63}}, {'s', {"D", 293.66}}, {'d', {"E", 329.63}},
        {'f', {"F", 349.23}}, {'g', {"G", 392.00}}, {'h', {"A", 440.00}},
        {'j', {"B", 493.88}}, {'k', {"C_high", 523.25}}, {'l', {"D_high", 587.33}}
    };
    std::string line;
    while (true) {
        std::cout << "\n입력: ";
        std::getline(std::cin, line);
        if (line == "exit") break;

        std::vector<std::shared_ptr<SoundElement>> song;

        for (char key : line) {
            if (key == ' ') {
                song.push_back(std::make_shared<RestNote>());
            }
            else if (notes.count(key)) {
                song.push_back(std::make_shared<ToneNote>(notes[key]));
            }
            else {
                std::cout << "(error: " << key << ")\n";
            }
        }

        std::vector<short> samples;
        for (const auto& element : song) {
            element->appendToBuffer(samples);
        }

        writeWavFile("output.wav", samples);
        PlaySoundA("output.wav", NULL, SND_FILENAME | SND_SYNC);
    }

    return 0;
}
